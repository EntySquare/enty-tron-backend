// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: message.order.proto

package message

import (
	fmt "fmt"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Order struct {
	OrderMessageId       *int32   `protobuf:"varint,1,req,name=orderMessageId" json:"orderMessageId,omitempty"`
	UserId               *string  `protobuf:"bytes,2,req,name=userId" json:"userId,omitempty"`
	OrderType            *string  `protobuf:"bytes,4,opt,name=orderType" json:"orderType,omitempty"`
	OrderStatus          *string  `protobuf:"bytes,5,opt,name=orderStatus,def=0" json:"orderStatus,omitempty"`
	OrderBalance         *string  `protobuf:"bytes,6,opt,name=orderBalance" json:"orderBalance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Order) Reset()         { *m = Order{} }
func (m *Order) String() string { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()    {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{0}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

const Default_Order_OrderStatus string = "0"

func (m *Order) GetOrderMessageId() int32 {
	if m != nil && m.OrderMessageId != nil {
		return *m.OrderMessageId
	}
	return 0
}

func (m *Order) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *Order) GetOrderType() string {
	if m != nil && m.OrderType != nil {
		return *m.OrderType
	}
	return ""
}

func (m *Order) GetOrderStatus() string {
	if m != nil && m.OrderStatus != nil {
		return *m.OrderStatus
	}
	return Default_Order_OrderStatus
}

func (m *Order) GetOrderBalance() string {
	if m != nil && m.OrderBalance != nil {
		return *m.OrderBalance
	}
	return ""
}

//orderStatus 0 待执行 1 已执行
// Topic case TRANSFER:
// -
// <GateHandler>/<OMS>: TRANSFER_ORDER
type TransferOrder struct {
	UserId               *string  `protobuf:"bytes,1,req,name=userId" json:"userId,omitempty"`
	ReceiverId           *string  `protobuf:"bytes,2,req,name=receiverId" json:"receiverId,omitempty"`
	OrderStatus          *string  `protobuf:"bytes,4,opt,name=orderStatus,def=0" json:"orderStatus,omitempty"`
	OrderBalance         *string  `protobuf:"bytes,5,opt,name=orderBalance" json:"orderBalance,omitempty"`
	Symbol               *string  `protobuf:"bytes,6,opt,name=symbol" json:"symbol,omitempty"`
	Memo                 *string  `protobuf:"bytes,7,opt,name=memo" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferOrder) Reset()         { *m = TransferOrder{} }
func (m *TransferOrder) String() string { return proto.CompactTextString(m) }
func (*TransferOrder) ProtoMessage()    {}
func (*TransferOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{1}
}
func (m *TransferOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferOrder.Merge(m, src)
}
func (m *TransferOrder) XXX_Size() int {
	return m.Size()
}
func (m *TransferOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferOrder.DiscardUnknown(m)
}

var xxx_messageInfo_TransferOrder proto.InternalMessageInfo

const Default_TransferOrder_OrderStatus string = "0"

func (m *TransferOrder) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *TransferOrder) GetReceiverId() string {
	if m != nil && m.ReceiverId != nil {
		return *m.ReceiverId
	}
	return ""
}

func (m *TransferOrder) GetOrderStatus() string {
	if m != nil && m.OrderStatus != nil {
		return *m.OrderStatus
	}
	return Default_TransferOrder_OrderStatus
}

func (m *TransferOrder) GetOrderBalance() string {
	if m != nil && m.OrderBalance != nil {
		return *m.OrderBalance
	}
	return ""
}

func (m *TransferOrder) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func (m *TransferOrder) GetMemo() string {
	if m != nil && m.Memo != nil {
		return *m.Memo
	}
	return ""
}

// Topic case WITHDRAW:
// -
// <GateHandler>/<OMS>: WITHDRAW_ORDER
type WithdrawOrder struct {
	UserId               *string  `protobuf:"bytes,1,req,name=userId" json:"userId,omitempty"`
	RevenueAddress       *string  `protobuf:"bytes,2,req,name=revenueAddress" json:"revenueAddress,omitempty"`
	OrderStatus          *string  `protobuf:"bytes,4,opt,name=orderStatus,def=0" json:"orderStatus,omitempty"`
	OrderBalance         *string  `protobuf:"bytes,5,opt,name=orderBalance" json:"orderBalance,omitempty"`
	Symbol               *string  `protobuf:"bytes,6,opt,name=symbol" json:"symbol,omitempty"`
	Memo                 *string  `protobuf:"bytes,7,opt,name=memo" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WithdrawOrder) Reset()         { *m = WithdrawOrder{} }
func (m *WithdrawOrder) String() string { return proto.CompactTextString(m) }
func (*WithdrawOrder) ProtoMessage()    {}
func (*WithdrawOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{2}
}
func (m *WithdrawOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawOrder.Merge(m, src)
}
func (m *WithdrawOrder) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawOrder.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawOrder proto.InternalMessageInfo

const Default_WithdrawOrder_OrderStatus string = "0"

func (m *WithdrawOrder) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *WithdrawOrder) GetRevenueAddress() string {
	if m != nil && m.RevenueAddress != nil {
		return *m.RevenueAddress
	}
	return ""
}

func (m *WithdrawOrder) GetOrderStatus() string {
	if m != nil && m.OrderStatus != nil {
		return *m.OrderStatus
	}
	return Default_WithdrawOrder_OrderStatus
}

func (m *WithdrawOrder) GetOrderBalance() string {
	if m != nil && m.OrderBalance != nil {
		return *m.OrderBalance
	}
	return ""
}

func (m *WithdrawOrder) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func (m *WithdrawOrder) GetMemo() string {
	if m != nil && m.Memo != nil {
		return *m.Memo
	}
	return ""
}

// Topic case GEN_PAY_ORDER:
// -
// <GateHandler>/<OMS>: PAY_ORDER
type PayOrder struct {
	OrderSerialNumber    *string  `protobuf:"bytes,1,req,name=orderSerialNumber" json:"orderSerialNumber,omitempty"`
	Payer                *string  `protobuf:"bytes,2,req,name=payer" json:"payer,omitempty"`
	Symbol               *string  `protobuf:"bytes,3,opt,name=symbol" json:"symbol,omitempty"`
	CallBackUrl          *string  `protobuf:"bytes,4,opt,name=callBackUrl" json:"callBackUrl,omitempty"`
	Memo                 *string  `protobuf:"bytes,7,opt,name=memo" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PayOrder) Reset()         { *m = PayOrder{} }
func (m *PayOrder) String() string { return proto.CompactTextString(m) }
func (*PayOrder) ProtoMessage()    {}
func (*PayOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{3}
}
func (m *PayOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayOrder.Merge(m, src)
}
func (m *PayOrder) XXX_Size() int {
	return m.Size()
}
func (m *PayOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_PayOrder.DiscardUnknown(m)
}

var xxx_messageInfo_PayOrder proto.InternalMessageInfo

func (m *PayOrder) GetOrderSerialNumber() string {
	if m != nil && m.OrderSerialNumber != nil {
		return *m.OrderSerialNumber
	}
	return ""
}

func (m *PayOrder) GetPayer() string {
	if m != nil && m.Payer != nil {
		return *m.Payer
	}
	return ""
}

func (m *PayOrder) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func (m *PayOrder) GetCallBackUrl() string {
	if m != nil && m.CallBackUrl != nil {
		return *m.CallBackUrl
	}
	return ""
}

func (m *PayOrder) GetMemo() string {
	if m != nil && m.Memo != nil {
		return *m.Memo
	}
	return ""
}

// Topic case DEPOSIT:
// -
// <OMS>/<ChainHandler>: DEPOSIT_ORDER
type DepositOrder struct {
	UserId               *string  `protobuf:"bytes,1,req,name=userId" json:"userId,omitempty"`
	FromAddress          *string  `protobuf:"bytes,2,req,name=fromAddress" json:"fromAddress,omitempty"`
	ReceiveAddress       *string  `protobuf:"bytes,3,req,name=receiveAddress" json:"receiveAddress,omitempty"`
	OrderStatus          *string  `protobuf:"bytes,5,opt,name=orderStatus,def=1" json:"orderStatus,omitempty"`
	OrderBalance         *string  `protobuf:"bytes,6,opt,name=orderBalance" json:"orderBalance,omitempty"`
	Symbol               *string  `protobuf:"bytes,7,opt,name=symbol" json:"symbol,omitempty"`
	Txs                  *string  `protobuf:"bytes,8,opt,name=txs" json:"txs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DepositOrder) Reset()         { *m = DepositOrder{} }
func (m *DepositOrder) String() string { return proto.CompactTextString(m) }
func (*DepositOrder) ProtoMessage()    {}
func (*DepositOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{4}
}
func (m *DepositOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositOrder.Merge(m, src)
}
func (m *DepositOrder) XXX_Size() int {
	return m.Size()
}
func (m *DepositOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositOrder.DiscardUnknown(m)
}

var xxx_messageInfo_DepositOrder proto.InternalMessageInfo

const Default_DepositOrder_OrderStatus string = "1"

func (m *DepositOrder) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *DepositOrder) GetFromAddress() string {
	if m != nil && m.FromAddress != nil {
		return *m.FromAddress
	}
	return ""
}

func (m *DepositOrder) GetReceiveAddress() string {
	if m != nil && m.ReceiveAddress != nil {
		return *m.ReceiveAddress
	}
	return ""
}

func (m *DepositOrder) GetOrderStatus() string {
	if m != nil && m.OrderStatus != nil {
		return *m.OrderStatus
	}
	return Default_DepositOrder_OrderStatus
}

func (m *DepositOrder) GetOrderBalance() string {
	if m != nil && m.OrderBalance != nil {
		return *m.OrderBalance
	}
	return ""
}

func (m *DepositOrder) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func (m *DepositOrder) GetTxs() string {
	if m != nil && m.Txs != nil {
		return *m.Txs
	}
	return ""
}

// Topic case GEN_PAY_ORDER:
// -
// <GateHandler>/<OMS>: MAKE_ORDER
type GeneratePayOrder struct {
	BUserId              *string  `protobuf:"bytes,1,req,name=bUserId" json:"bUserId,omitempty"`
	OrderBalance         *string  `protobuf:"bytes,2,opt,name=orderBalance" json:"orderBalance,omitempty"`
	Symbol               *string  `protobuf:"bytes,3,opt,name=symbol" json:"symbol,omitempty"`
	Memo                 *string  `protobuf:"bytes,4,opt,name=memo" json:"memo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeneratePayOrder) Reset()         { *m = GeneratePayOrder{} }
func (m *GeneratePayOrder) String() string { return proto.CompactTextString(m) }
func (*GeneratePayOrder) ProtoMessage()    {}
func (*GeneratePayOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{5}
}
func (m *GeneratePayOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneratePayOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneratePayOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneratePayOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneratePayOrder.Merge(m, src)
}
func (m *GeneratePayOrder) XXX_Size() int {
	return m.Size()
}
func (m *GeneratePayOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneratePayOrder.DiscardUnknown(m)
}

var xxx_messageInfo_GeneratePayOrder proto.InternalMessageInfo

func (m *GeneratePayOrder) GetBUserId() string {
	if m != nil && m.BUserId != nil {
		return *m.BUserId
	}
	return ""
}

func (m *GeneratePayOrder) GetOrderBalance() string {
	if m != nil && m.OrderBalance != nil {
		return *m.OrderBalance
	}
	return ""
}

func (m *GeneratePayOrder) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func (m *GeneratePayOrder) GetMemo() string {
	if m != nil && m.Memo != nil {
		return *m.Memo
	}
	return ""
}

// Topic case WITHDRAW:
// -
// <OMS>/<ChainHandler>: TRANSACTION
type Transaction struct {
	SendAddress          *string  `protobuf:"bytes,1,req,name=sendAddress" json:"sendAddress,omitempty"`
	RevenueAddress       *string  `protobuf:"bytes,2,req,name=revenueAddress" json:"revenueAddress,omitempty"`
	OrderSerialNumber    *string  `protobuf:"bytes,3,opt,name=orderSerialNumber" json:"orderSerialNumber,omitempty"`
	Balance              *string  `protobuf:"bytes,4,opt,name=balance" json:"balance,omitempty"`
	Symbol               *string  `protobuf:"bytes,5,opt,name=symbol" json:"symbol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_8594aa3e873e58b3, []int{6}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetSendAddress() string {
	if m != nil && m.SendAddress != nil {
		return *m.SendAddress
	}
	return ""
}

func (m *Transaction) GetRevenueAddress() string {
	if m != nil && m.RevenueAddress != nil {
		return *m.RevenueAddress
	}
	return ""
}

func (m *Transaction) GetOrderSerialNumber() string {
	if m != nil && m.OrderSerialNumber != nil {
		return *m.OrderSerialNumber
	}
	return ""
}

func (m *Transaction) GetBalance() string {
	if m != nil && m.Balance != nil {
		return *m.Balance
	}
	return ""
}

func (m *Transaction) GetSymbol() string {
	if m != nil && m.Symbol != nil {
		return *m.Symbol
	}
	return ""
}

func init() {
	proto.RegisterType((*Order)(nil), "message.Order")
	proto.RegisterType((*TransferOrder)(nil), "message.TransferOrder")
	proto.RegisterType((*WithdrawOrder)(nil), "message.WithdrawOrder")
	proto.RegisterType((*PayOrder)(nil), "message.PayOrder")
	proto.RegisterType((*DepositOrder)(nil), "message.DepositOrder")
	proto.RegisterType((*GeneratePayOrder)(nil), "message.GeneratePayOrder")
	proto.RegisterType((*Transaction)(nil), "message.Transaction")
}

func init() { proto.RegisterFile("message.order.proto", fileDescriptor_8594aa3e873e58b3) }

var fileDescriptor_8594aa3e873e58b3 = []byte{
	// 478 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x53, 0x3d, 0x8f, 0xd3, 0x40,
	0x14, 0x64, 0x93, 0xf8, 0x72, 0x79, 0xb9, 0x3b, 0x85, 0x05, 0x21, 0x17, 0xc8, 0xb2, 0x8c, 0x74,
	0x4a, 0x81, 0x4e, 0xd0, 0xd2, 0x11, 0x21, 0xa1, 0x2b, 0xf8, 0x50, 0xb8, 0x13, 0xf5, 0xc6, 0x7e,
	0x07, 0x16, 0xfe, 0x88, 0xde, 0x6e, 0x0e, 0x22, 0xf1, 0x43, 0x28, 0xf8, 0x0d, 0xb4, 0x34, 0x94,
	0x14, 0x94, 0xfc, 0x04, 0x94, 0xfb, 0x23, 0xc8, 0xbb, 0x6b, 0x6e, 0x9d, 0x98, 0x28, 0x54, 0x74,
	0x3b, 0xf3, 0x56, 0x7e, 0x33, 0xb3, 0x63, 0xb8, 0x95, 0xa3, 0x94, 0xe2, 0x0d, 0x9e, 0x94, 0x94,
	0x20, 0x9d, 0xcc, 0xa9, 0x54, 0x25, 0xef, 0x5b, 0x32, 0xfa, 0xc2, 0xc0, 0x7b, 0x51, 0x0d, 0xf8,
	0x31, 0x1c, 0xe9, 0x1b, 0xcf, 0xcc, 0xe4, 0x34, 0xf1, 0x59, 0xd8, 0x19, 0x7b, 0xd3, 0x35, 0x96,
	0xdf, 0x81, 0xbd, 0x85, 0x44, 0x3a, 0x4d, 0xfc, 0x4e, 0xd8, 0x19, 0x0f, 0xa6, 0x16, 0xf1, 0xbb,
	0x30, 0xd0, 0x37, 0xcf, 0x96, 0x73, 0xf4, 0x7b, 0x21, 0x1b, 0x0f, 0xa6, 0xd7, 0x04, 0xbf, 0x07,
	0x43, 0x0d, 0x5e, 0x29, 0xa1, 0x16, 0xd2, 0xf7, 0xaa, 0xf9, 0x23, 0xf6, 0x60, 0xea, 0xb2, 0x3c,
	0x82, 0x03, 0x0d, 0x27, 0x22, 0x13, 0x45, 0x8c, 0xfe, 0x9e, 0xfe, 0x4a, 0x83, 0x8b, 0xbe, 0x31,
	0x38, 0x3c, 0x23, 0x51, 0xc8, 0x0b, 0x24, 0x23, 0xfc, 0x5a, 0x10, 0x6b, 0x08, 0x0a, 0x00, 0x08,
	0x63, 0x4c, 0x2f, 0x1d, 0xb1, 0x0e, 0xb3, 0x2e, 0xa9, 0xb7, 0x93, 0x24, 0x6f, 0x53, 0x52, 0x25,
	0x40, 0x2e, 0xf3, 0x59, 0x99, 0x59, 0xc1, 0x16, 0x71, 0x0e, 0xbd, 0x1c, 0xf3, 0xd2, 0xef, 0x6b,
	0x56, 0x9f, 0xa3, 0xef, 0x0c, 0x0e, 0x5f, 0xa7, 0xea, 0x6d, 0x42, 0xe2, 0xfd, 0x76, 0xf9, 0xc7,
	0x70, 0x44, 0x78, 0x89, 0xc5, 0x02, 0x1f, 0x27, 0x09, 0xa1, 0x94, 0xd6, 0xc2, 0x1a, 0xfb, 0x7f,
	0x6c, 0x7c, 0x66, 0xb0, 0xff, 0x52, 0x2c, 0x8d, 0x83, 0xfb, 0x70, 0xd3, 0xec, 0x42, 0x4a, 0x45,
	0xf6, 0x7c, 0x91, 0xcf, 0x90, 0xac, 0x99, 0xcd, 0x01, 0xbf, 0x0d, 0xde, 0x5c, 0x2c, 0x91, 0xac,
	0x1d, 0x03, 0x9c, 0xe5, 0xdd, 0xc6, 0xf2, 0x10, 0x86, 0xb1, 0xc8, 0xb2, 0x89, 0x88, 0xdf, 0x9d,
	0x53, 0x66, 0x7b, 0xe5, 0x52, 0xad, 0xf2, 0xae, 0x18, 0x1c, 0x3c, 0xc1, 0x79, 0x29, 0x53, 0xb5,
	0x3d, 0xe4, 0x10, 0x86, 0x17, 0x54, 0xe6, 0xcd, 0x84, 0x5d, 0xca, 0x3c, 0x83, 0xee, 0x4c, 0x7d,
	0xa9, 0x5b, 0x3f, 0x83, 0xcb, 0xfe, 0xa5, 0xe0, 0x0f, 0xff, 0xb9, 0xe0, 0x4e, 0x12, 0xfd, 0x46,
	0x12, 0x23, 0xe8, 0xaa, 0x0f, 0xd2, 0xdf, 0xd7, 0x64, 0x75, 0x8c, 0x3e, 0xc2, 0xe8, 0x29, 0x16,
	0x48, 0x42, 0xe1, 0x9f, 0xb7, 0xf0, 0xa1, 0x3f, 0x3b, 0x77, 0x9d, 0xd6, 0x70, 0x63, 0x77, 0x67,
	0xeb, 0xee, 0x6e, 0x6b, 0x05, 0x7a, 0x4e, 0xc6, 0x5f, 0x19, 0x0c, 0xf5, 0x8f, 0x28, 0x62, 0x95,
	0x96, 0x45, 0x15, 0xa5, 0xc4, 0x22, 0xa9, 0x53, 0x32, 0xdb, 0x5d, 0x6a, 0xe7, 0x46, 0xb7, 0xf6,
	0xc9, 0x08, 0x6a, 0xe9, 0x53, 0xe5, 0xd8, 0x5a, 0x32, 0xf2, 0x6a, 0xe8, 0xb8, 0xf1, 0x5c, 0x37,
	0x93, 0xd1, 0x8f, 0x55, 0xc0, 0x7e, 0xae, 0x02, 0xf6, 0x6b, 0x15, 0xb0, 0x4f, 0x57, 0xc1, 0x8d,
	0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x19, 0xe3, 0xa2, 0x7d, 0x24, 0x05, 0x00, 0x00,
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OrderBalance != nil {
		i -= len(*m.OrderBalance)
		copy(dAtA[i:], *m.OrderBalance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderBalance)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderStatus != nil {
		i -= len(*m.OrderStatus)
		copy(dAtA[i:], *m.OrderStatus)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderStatus)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OrderType != nil {
		i -= len(*m.OrderType)
		copy(dAtA[i:], *m.OrderType)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderType)))
		i--
		dAtA[i] = 0x22
	}
	if m.UserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.UserId)
		copy(dAtA[i:], *m.UserId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.UserId)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderMessageId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintMessageOrder(dAtA, i, uint64(*m.OrderMessageId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memo != nil {
		i -= len(*m.Memo)
		copy(dAtA[i:], *m.Memo)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderBalance != nil {
		i -= len(*m.OrderBalance)
		copy(dAtA[i:], *m.OrderBalance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderBalance)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OrderStatus != nil {
		i -= len(*m.OrderStatus)
		copy(dAtA[i:], *m.OrderStatus)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderStatus)))
		i--
		dAtA[i] = 0x22
	}
	if m.ReceiverId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ReceiverId)
		copy(dAtA[i:], *m.ReceiverId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.ReceiverId)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.UserId)
		copy(dAtA[i:], *m.UserId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memo != nil {
		i -= len(*m.Memo)
		copy(dAtA[i:], *m.Memo)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderBalance != nil {
		i -= len(*m.OrderBalance)
		copy(dAtA[i:], *m.OrderBalance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderBalance)))
		i--
		dAtA[i] = 0x2a
	}
	if m.OrderStatus != nil {
		i -= len(*m.OrderStatus)
		copy(dAtA[i:], *m.OrderStatus)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderStatus)))
		i--
		dAtA[i] = 0x22
	}
	if m.RevenueAddress == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.RevenueAddress)
		copy(dAtA[i:], *m.RevenueAddress)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.RevenueAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.UserId)
		copy(dAtA[i:], *m.UserId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memo != nil {
		i -= len(*m.Memo)
		copy(dAtA[i:], *m.Memo)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Memo)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CallBackUrl != nil {
		i -= len(*m.CallBackUrl)
		copy(dAtA[i:], *m.CallBackUrl)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.CallBackUrl)))
		i--
		dAtA[i] = 0x22
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Payer == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Payer)
		copy(dAtA[i:], *m.Payer)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Payer)))
		i--
		dAtA[i] = 0x12
	}
	if m.OrderSerialNumber == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.OrderSerialNumber)
		copy(dAtA[i:], *m.OrderSerialNumber)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderSerialNumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Txs != nil {
		i -= len(*m.Txs)
		copy(dAtA[i:], *m.Txs)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Txs)))
		i--
		dAtA[i] = 0x42
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OrderBalance != nil {
		i -= len(*m.OrderBalance)
		copy(dAtA[i:], *m.OrderBalance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderBalance)))
		i--
		dAtA[i] = 0x32
	}
	if m.OrderStatus != nil {
		i -= len(*m.OrderStatus)
		copy(dAtA[i:], *m.OrderStatus)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderStatus)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReceiveAddress == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ReceiveAddress)
		copy(dAtA[i:], *m.ReceiveAddress)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.ReceiveAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FromAddress == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.FromAddress)
		copy(dAtA[i:], *m.FromAddress)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.FromAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.UserId)
		copy(dAtA[i:], *m.UserId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeneratePayOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratePayOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneratePayOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Memo != nil {
		i -= len(*m.Memo)
		copy(dAtA[i:], *m.Memo)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Memo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OrderBalance != nil {
		i -= len(*m.OrderBalance)
		copy(dAtA[i:], *m.OrderBalance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderBalance)))
		i--
		dAtA[i] = 0x12
	}
	if m.BUserId == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BUserId)
		copy(dAtA[i:], *m.BUserId)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.BUserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Symbol != nil {
		i -= len(*m.Symbol)
		copy(dAtA[i:], *m.Symbol)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Symbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Balance != nil {
		i -= len(*m.Balance)
		copy(dAtA[i:], *m.Balance)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.Balance)))
		i--
		dAtA[i] = 0x22
	}
	if m.OrderSerialNumber != nil {
		i -= len(*m.OrderSerialNumber)
		copy(dAtA[i:], *m.OrderSerialNumber)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.OrderSerialNumber)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RevenueAddress == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.RevenueAddress)
		copy(dAtA[i:], *m.RevenueAddress)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.RevenueAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.SendAddress == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.SendAddress)
		copy(dAtA[i:], *m.SendAddress)
		i = encodeVarintMessageOrder(dAtA, i, uint64(len(*m.SendAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessageOrder(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessageOrder(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderMessageId != nil {
		n += 1 + sovMessageOrder(uint64(*m.OrderMessageId))
	}
	if m.UserId != nil {
		l = len(*m.UserId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderType != nil {
		l = len(*m.OrderType)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderStatus != nil {
		l = len(*m.OrderStatus)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderBalance != nil {
		l = len(*m.OrderBalance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != nil {
		l = len(*m.UserId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.ReceiverId != nil {
		l = len(*m.ReceiverId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderStatus != nil {
		l = len(*m.OrderStatus)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderBalance != nil {
		l = len(*m.OrderBalance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Memo != nil {
		l = len(*m.Memo)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WithdrawOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != nil {
		l = len(*m.UserId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.RevenueAddress != nil {
		l = len(*m.RevenueAddress)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderStatus != nil {
		l = len(*m.OrderStatus)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderBalance != nil {
		l = len(*m.OrderBalance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Memo != nil {
		l = len(*m.Memo)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderSerialNumber != nil {
		l = len(*m.OrderSerialNumber)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Payer != nil {
		l = len(*m.Payer)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.CallBackUrl != nil {
		l = len(*m.CallBackUrl)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Memo != nil {
		l = len(*m.Memo)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DepositOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != nil {
		l = len(*m.UserId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.FromAddress != nil {
		l = len(*m.FromAddress)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.ReceiveAddress != nil {
		l = len(*m.ReceiveAddress)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderStatus != nil {
		l = len(*m.OrderStatus)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderBalance != nil {
		l = len(*m.OrderBalance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Txs != nil {
		l = len(*m.Txs)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GeneratePayOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BUserId != nil {
		l = len(*m.BUserId)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderBalance != nil {
		l = len(*m.OrderBalance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Memo != nil {
		l = len(*m.Memo)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SendAddress != nil {
		l = len(*m.SendAddress)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.RevenueAddress != nil {
		l = len(*m.RevenueAddress)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.OrderSerialNumber != nil {
		l = len(*m.OrderSerialNumber)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Balance != nil {
		l = len(*m.Balance)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.Symbol != nil {
		l = len(*m.Symbol)
		n += 1 + l + sovMessageOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessageOrder(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessageOrder(x uint64) (n int) {
	return sovMessageOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Order) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderMessageId", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OrderMessageId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderType = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderStatus = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderBalance = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferOrder) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReceiverId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderStatus = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderBalance = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Memo = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawOrder) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevenueAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RevenueAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderStatus = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderBalance = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Memo = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayOrder) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderSerialNumber = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Payer = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallBackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CallBackUrl = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Memo = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositOrder) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FromAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReceiveAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderStatus = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderBalance = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Txs = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratePayOrder) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratePayOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratePayOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BUserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BUserId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderBalance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderBalance = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Memo = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SendAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevenueAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RevenueAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderSerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OrderSerialNumber = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Balance = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessageOrder
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Symbol = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessageOrder(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessageOrder
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessageOrder(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessageOrder
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessageOrder
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessageOrder
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessageOrder
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessageOrder
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessageOrder        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessageOrder          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessageOrder = fmt.Errorf("proto: unexpected end of group")
)
